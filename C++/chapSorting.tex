\chapter{排序}

\section{快速排序} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
详细解释请参考本项目的wiki，\myurl{https://github.com/soulmachine/acm-cheatsheet/wiki/快速排序}

\begin{Codex}[label=quick_sort.c]
/** 数组元素的类型 */
typedef int elem_t;
 /*
  * @brief 一趟划分.
  * @param[inout] a 待排序元素序列
  * @param[in] start 开始位置
  * @param[in] end 结束位置，最后一个元素后一个位置
  * @return 基准元素的新位置
  */
int partition(elem_t a[], const int start, const int end) {
    int i = start;
    int j = end - 1;
    const elem_t pivot = a[i];

    while(i < j) {
        while(i < j && a[j] >= pivot) j--;
        a[i] = a[j];
        while(i < j && a[i] <= pivot) i++;
        a[j] = a[i];
    }
    a[i] = pivot;
    return i;
}

/**
  * @brief 快速排序.
  * @param[inout] a 待排序元素序列
  * @param[in] start 开始位置
  * @param[in] end 结束位置，最后一个元素后一个位置
  * @return 无
  */
void quick_sort(elem_t a[], const int start, const int end) {
    if(start < end - 1) { /* 至少两个元素*/
        const int pivot_pos = partition(a, start, end);
        quick_sort(a, start, pivot_pos);
        quick_sort(a, pivot_pos + 1, end);
    }
}
\end{Codex}

\section{归并排序} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{Codex}[label=quick_sort.c]
typedef int elem_t;
const int MAXN = 100; //数组范围
elem_t a[MAXN];       //待排序数组
elem_t b[MAXN];       //辅助数组

//参数是起点和终点
void merge_sort(int s, int e)
{
    if (e - s <= 0)return;
    int mid = (s + e) / 2, p1 = s, p2 = mid + 1, i = s;
    merge_sort(s, mid);
    merge_sort(mid + 1, e);
    while (p1 <= mid || p2 <= e)
    {
        if (p2 > e || (p1 <= mid && a[p1] <= a[p2]))
            b[i++] = a[p1++];
        else b[i++] = a[p2++];
    }
    for (i = s; i <= e; i++)
        a[i] = b[i];
}
\end{Codex}